package main

import (
	"auth/internal/server"
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
)

func main() {

	// Создаем новый сервер, используя функцию NewServer из пакета server.
	srv := server.NewServer()

	// Запускаем сервер в отдельной горутине.
	// Это позволяет продолжить выполнение основного потока и обработать другие задачи.
	go func() {
		// При запуске сервера, ListenAndServe() блокирует выполнение до тех пор,
		// пока сервер не будет остановлен или не произойдет ошибка.
		// Ошибка будет возвращена только в случае непредвиденной ошибки.
		// К примеру, если порт уже занят другим приложением.
		err := srv.ListenAndServe()
		if err != nil {
			// Если произошла ошибка при запуске сервера, логируем ее и завершаем работу программы.
			// Приложение не продолжит работу, если возникнет ошибка запуска сервера.
			log.Fatalf("Server startup error: %v", err)
		}
	}()

	// Ожидаем получение сигнала завершения работы сервера (SIGINT или SIGTERM).
	// Это позволит корректно завершить работу сервера при получении сигнала завершения.
	// Когда сервер получает сигнал завершения, он завершает работу и выходит из программы.
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	<-sigChan

	// Когда получен сигнал завершения, останавливаем сервер.
	err := srv.Shutdown(context.Background())
	if err != nil {
		// Если произошла ошибка при остановке сервера, логируем ее.
		// Однако, программа продолжит завершение.
		log.Printf("Server shutdown error: %v", err)
	}

	// Логируем завершение работы сервера и завершаем выполнение программы.
	log.Println("Server stopped gracefully")
}
